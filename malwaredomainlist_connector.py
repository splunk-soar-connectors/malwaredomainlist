# --
# File: malwaredomainlist/malwaredomainlist_connector.py
#
# Copyright (c) Phantom Cyber Corporation, 2017
#
# This unpublished material is proprietary to Phantom Cyber.
# All rights reserved. The methods and
# techniques described herein are considered trade secrets
# and/or confidential. Reproduction or distribution, in whole
# or in part, is forbidden except by express written permission
# of Phantom Cyber Corporation.
#
# --

# Standard library imports
import re
import json
import requests
from bs4 import BeautifulSoup

# Phantom imports
import phantom.app as phantom
from phantom.base_connector import BaseConnector
from phantom.action_result import ActionResult

# Local imports
import malwaredomainlist_consts as consts

# Dictionary that maps each error code with its corresponding message
# Eg: {200: Success}
ERROR_RESP_DICT = {
    consts.MDL_REST_RESP_BAD_REQUEST: consts.MDL_REST_RESP_BAD_REQUEST_MSG,
    consts.MDL_REST_RESP_FORBIDDEN: consts.MDL_REST_RESP_FORBIDDEN_MSG,
    consts.MDL_REST_RESP_SERVICE_UNAVAILABLE: consts.MDL_REST_RESP_SERVICE_UNAVAILABLE_MSG,
    consts.MDL_REST_RESP_INTERNAL_ERROR: consts.MDL_REST_RESP_INTERNAL_ERROR_MSG,
    consts.MDL_REST_RESP_METHOD_NOT_ALLOWED: consts.MDL_REST_RESP_METHOD_NOT_ALLOWED_MSG,
    consts.MDL_REST_RESP_NOT_FOUND: consts.MDL_REST_RESP_NOT_FOUND_MSG
}


class MalwareDomainListConnector(BaseConnector):

    def __init__(self):

        # Calling the BaseConnector's init function
        super(MalwareDomainListConnector, self).__init__()
        self._base_url = None
        return

    def initialize(self):
        """ This is an optional function that can be implemented by the AppConnector derived class. Since the
        configuration dictionary is already validated by the time this function is called, it's a good place to do any
        extra initialization of any internal modules. This function MUST return a value of either phantom.APP_SUCCESS or
        phantom.APP_ERROR. If this function returns phantom.APP_ERROR, then AppConnector::handle_action will not get
        called.
        """

        config = self.get_config()

        # Initialize configuration parameters
        self._base_url = config[consts.MDL_CONFIG_SERVER].strip('/')

        return phantom.APP_SUCCESS

    def _make_rest_call(self, endpoint, action_result, data=None, method="post"):
        """ Function that makes the REST call to the device. It is a generic function that can be called from various
        action handlers.

        :param endpoint: REST endpoint that needs to appended to the service address
        :param action_result: object of ActionResult class
        :param data: request body
        :param method: method used for making request (Default method is 'post')
        :return: status success/failure(along with appropriate message), response obtained by making an API call
        """

        response_data = None

        if not data:
            data = {}

        # All API calls supports POST request
        try:
            request_func = getattr(requests, method)
        except AttributeError:
            self.debug_print(consts.MDL_ERR_API_UNSUPPORTED_METHOD)
            # set the action_result status to error, the handler function will most probably return as is
            return action_result.set_status(phantom.APP_ERROR, consts.MDL_ERR_API_UNSUPPORTED_METHOD), response_data
        except Exception as e:
            self.debug_print(consts.MDL_EXCEPTION_OCCURRED.format(error=e))
            # set the action_result status to error, the handler function will most probably return as is
            return action_result.set_status(phantom.APP_ERROR, e), response_data

        try:
            response = request_func('{}{}'.format(self._base_url, endpoint), params=data)
        except Exception as error:
            self.debug_print(consts.MDL_REST_CALL_ERROR.format(error=str(error)))
            # Set the action_result status to error, the handler function will most probably return as is
            return action_result.set_status(phantom.APP_ERROR, consts.MDL_ERR_SERVER_CONNECTION,
                                            error.message), response_data

        # store the r_text in debug data, it will get dumped in the logs if an error occurs
        if hasattr(action_result, 'add_debug_data'):
            if (response is not None):
                action_result.add_debug_data({'r_status_code': response.status_code})
                action_result.add_debug_data({'r_text': response.text})
                action_result.add_debug_data({'r_headers': response.headers})
            else:
                action_result.add_debug_data({'r_text': 'r is None'})

        if response.status_code in ERROR_RESP_DICT:
            self.debug_print(consts.MDL_ERR_FROM_SERVER.format(status=response.status_code,
                                                               detail=ERROR_RESP_DICT[response.status_code],
                                                               reason=response.content))

            # Set the action_result status to error, the handler function will most probably return as is
            return action_result.set_status(phantom.APP_ERROR, '{0}'.format(consts.MDL_ERR_FROM_SERVER),
                                            status=response.status_code,
                                            detail=ERROR_RESP_DICT[response.status_code],
                                            reason=response.content), response_data

        if response.status_code == consts.MDL_SUCCESS_RESPONSE:
            return phantom.APP_SUCCESS, {consts.MDL_REST_RESPONSE: response.content,
                                         consts.MDL_REST_RESPONSE_HEADERS: response.headers}

        # Set the action_result status to error, the handler function will most probably return as is
        return action_result.set_status(phantom.APP_ERROR, consts.MDL_ERR_FROM_SERVER,
                                        status=response.status_code,
                                        detail=consts.MDL_UNKNOWN_ERROR,
                                        reason=response.content), response.content

    def _parse_response(self, response_content, action_result, summary_data):
        soup = BeautifulSoup(response_content, "html.parser")
        keys = []
        # get data paths
        for i, r in enumerate(soup.findAll("tr", {"class": "tabletitle"})):
            for j, c in enumerate(r.findAll("td")):
                try:
                    keys += [c.contents[0].get_text()]
                except AttributeError:  # AttributeError: 'NavigableString' object has no attribute 'get_text'
                    keys += [c.contents[0]]
                except IndexError:
                    pass
                except Exception:
                    pass
            break
        keys = [re.sub("[ ()]", "", k) for k in keys]

        # get ioc
        malicious = 0
        processed_everything = len(keys) > 0
        for i, r in enumerate(soup.findAll("tr", {"onmouseover": "this.style.backgroundColor='#b6bac6'"})):
            malicious += 1
            data = {}
            try:
                for j, c in enumerate(r.findAll("td")):
                    if j < len(keys):
                        value = re.sub('<[^>]*>', '', unicode(c))
                        if value[-1] == "." and keys[j] == consts.MDL_JSON_DATAPATH_REVERSE_LOOKUP:
                            data[keys[j]] = value[:-1]
                        elif value == "-" and keys[j] == consts.MDL_JSON_DATAPATH_DOMAIN:  # IP contains domain
                            pass
                        elif "/" in value and keys[j] == consts.MDL_JSON_DATAPATH_IP:      # IP contains domain
                            data[keys[j]] = value[: value.find("/")]
                            data[consts.MDL_JSON_DATAPATH_DOMAIN] = value
                        else:
                            data[keys[j]] = value
                    else:
                        for country in c.findAll("img", {"class": True, "title": True, "alt": True}):
                            data[consts.MDL_JSON_DATAPATH_COUNTRY] = country["title"]
                            data[consts.MDL_JSON_DATAPATH_COUNTRY_CODE] = country["alt"]
                            break
                action_result.add_data(data)
            except:
                processed_everything = False

        summary_data.update({"matching_records": malicious})
        summary_data.update({"malicious": True if malicious > 0 else False})

        if (not processed_everything):
            return action_result.set_status(phantom.APP_ERROR, "Some of the data could not be processed")

        return phantom.APP_SUCCESS

    def _ip_reputation(self, param):
        """ Function to query Malware Domain List to get IP details.

        :param param: dictionary of input parameter containing IP
        :return: status success/failure
        """

        action_result = self.add_action_result(ActionResult(dict(param)))
        summary_data = action_result.update_summary({})

        # getting parameters
        inactive = param.get(consts.MDL_JSON_INCLUDE_INACTIVE, False)
        ip = param[consts.MDL_JSON_IP]

        api_params = {consts.MDL_JSON_COLSEARCH: consts.MDL_JSON_PARAM_IP, consts.MDL_JSON_QUANTITY: consts.MDL_JSON_PARAM_ALL,
            consts.MDL_JSON_ASCORDESC: consts.MDL_JSON_PARAM_DESC}
        api_params[consts.MDL_JSON_SEARCH] = ip
        if inactive:
            api_params[consts.MDL_JSON_INACTIVE] = consts.MDL_JSON_PARAM_INACTIVE_ON

        # make REST call
        response_status, response_data = self._make_rest_call(consts.MDL_SEARCH_ENDPOINT, action_result,
                                                              data=api_params, method="get")

        if phantom.is_fail(response_status):
            return action_result.get_status()

        # parse results
        ret_val = self._parse_response(response_data[consts.MDL_REST_RESPONSE], action_result, summary_data)

        if (phantom.is_fail(ret_val)):
            return action_result.get_status()

        return action_result.set_status(phantom.APP_SUCCESS)

    def _domain_reputation(self, param):
        """ Function to query Malware Domain List to get domain details.

        :param param: domain to search
        :return: status success/failure
        """

        action_result = self.add_action_result(ActionResult(dict(param)))
        summary_data = action_result.update_summary({})

        # getting parameters
        inactive = param.get(consts.MDL_JSON_INCLUDE_INACTIVE, False)
        domain = param[consts.MDL_JSON_DOMAIN]

        # Convert URL to domain
        if phantom.is_url(domain):
            domain = phantom.get_host_from_url(domain)

        api_params = {consts.MDL_JSON_COLSEARCH: consts.MDL_JSON_PARAM_DOMAIN, consts.MDL_JSON_QUANTITY: consts.MDL_JSON_PARAM_ALL,
            consts.MDL_JSON_ASCORDESC: consts.MDL_JSON_PARAM_DESC}
        api_params[consts.MDL_JSON_SEARCH] = domain
        if inactive:
            api_params[consts.MDL_JSON_INACTIVE] = consts.MDL_JSON_PARAM_INACTIVE_ON

        # make REST call
        response_status, response_data = self._make_rest_call(consts.MDL_SEARCH_ENDPOINT, action_result,
                                                              data=api_params, method="get")

        if phantom.is_fail(response_status):
            return action_result.get_status()

        # parse results
        ret_val = self._parse_response(response_data[consts.MDL_REST_RESPONSE], action_result, summary_data)

        if (phantom.is_fail(ret_val)):
            return action_result.get_status()

        return action_result.set_status(phantom.APP_SUCCESS)

    def handle_action(self, param):
        """ This function gets current action identifier and calls member function of its own to handle the action.

        :param param: dictionary which contains information about the actions to be executed
        :return: status success/failure
        """

        # Dictionary mapping each action with its corresponding actions
        action_mapping = {
            'ip_reputation': self._ip_reputation,
            'domain_reputation': self._domain_reputation
        }

        action = self.get_action_identifier()
        action_execution_status = phantom.APP_SUCCESS

        if action in action_mapping.keys():
            action_function = action_mapping[action]
            action_execution_status = action_function(param)

        return action_execution_status


if __name__ == '__main__':

    import sys
    import pudb

    pudb.set_trace()
    if len(sys.argv) < 2:
        print 'No test json specified as input'
        exit(0)
    with open(sys.argv[1]) as f:
        in_json = f.read()
        in_json = json.loads(in_json)
        print json.dumps(in_json, indent=4)
        connector = MalwareDomainListConnector()
        connector.print_progress_message = True
        return_value = connector._handle_action(json.dumps(in_json), None)
        print json.dumps(json.loads(return_value), indent=4)
    exit(0)
