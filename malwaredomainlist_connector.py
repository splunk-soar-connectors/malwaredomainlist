# --
# File: malwaredomainlist_connector.py

# Copyright (c) 2017-2021 Splunk Inc.

# SPLUNK CONFIDENTIAL - Use or disclosure of this material in whole or in part
# without a valid written license from Splunk Inc. is PROHIBITED.
# --

# Standard library imports
import re
import json
import requests
try:
    from urllib.parse import urlparse
except ImportError:
    from urlparse import urlparse
from bs4 import BeautifulSoup, UnicodeDammit
import sys

# Phantom imports
import phantom.app as phantom
from phantom.base_connector import BaseConnector
from phantom.action_result import ActionResult

# Local imports
import malwaredomainlist_consts as consts

# Dictionary that maps each error code with its corresponding message
# Eg: {200: Success}
ERROR_RESP_DICT = {
    consts.MDL_REST_RESP_BAD_REQUEST: consts.MDL_REST_RESP_BAD_REQUEST_MSG,
    consts.MDL_REST_RESP_FORBIDDEN: consts.MDL_REST_RESP_FORBIDDEN_MSG,
    consts.MDL_REST_RESP_SERVICE_UNAVAILABLE: consts.MDL_REST_RESP_SERVICE_UNAVAILABLE_MSG,
    consts.MDL_REST_RESP_INTERNAL_ERROR: consts.MDL_REST_RESP_INTERNAL_ERROR_MSG,
    consts.MDL_REST_RESP_METHOD_NOT_ALLOWED: consts.MDL_REST_RESP_METHOD_NOT_ALLOWED_MSG,
    consts.MDL_REST_RESP_NOT_FOUND: consts.MDL_REST_RESP_NOT_FOUND_MSG
}


class MalwareDomainListConnector(BaseConnector):

    def __init__(self):

        # Calling the BaseConnector's init function
        super(MalwareDomainListConnector, self).__init__()
        self._base_url = None
        self._python_version = None
        return

    def _handle_py_ver_compat_for_input_str(self, input_str):
        """
        This method returns the encoded|original string based on the Python version.
        :param input_str: Input string to be processed
        :return: input_str (Processed input string based on following logic 'input_str - Python 3; encoded input_str - Python 2')
        """
        try:
            if input_str and self._python_version < 3:
                input_str = UnicodeDammit(input_str).unicode_markup.encode('utf-8')
        except:
            self.debug_print("Error occurred while handling python 2to3 compatibility for the input string")

        return input_str

    def _get_error_message_from_exception(self, e):
        """ This function is used to get appropriate error message from the exception.
        :param e: Exception object
        :return: error message
        """
        error_msg = "Error message unavailable. Please check the asset configuration and|or action parameters."
        error_code = "Error code unavailable"
        try:
            if hasattr(e, 'args'):
                if len(e.args) > 1:
                    error_code = e.args[0]
                    error_msg = e.args[1]
                elif len(e.args) == 1:
                    error_code = "Error code unavailable"
                    error_msg = e.args[0]
            else:
                error_code = "Error code unavailable"
                error_msg = "Error message unavailable. Please check the asset configuration and|or action parameters."
        except:
            error_code = "Error code unavailable"
            error_msg = "Error message unavailable. Please check the asset configuration and|or action parameters."

        try:
            error_msg = self._handle_py_ver_compat_for_input_str(error_msg)
        except TypeError:
            error_msg = "Error occurred while connecting to the Malware Domain List server. Please check the asset configuration and|or the action parameters."
        except:
            error_msg = "Error message unavailable. Please check the asset configuration and|or action parameters."

        return "Error Code: {0}. Error Message: {1}".format(error_code, error_msg)

    def validate_param(self, param):

        if (phantom.is_url(param)):
            # it's a url, the action handler does the job of extracting
            # the domain and passing that value
            return True

        if (phantom.is_domain(param)):
            return True

        # append http to make it a url
        param_as_url = "http://{0}".format(param)

        domain = phantom.get_host_from_url(param_as_url)

        if (not domain):
            # at this point nothing seems right
            return False

        return True

    def initialize(self):
        """ This is an optional function that can be implemented by the AppConnector derived class. Since the
        configuration dictionary is already validated by the time this function is called, it's a good place to do any
        extra initialization of any internal modules. This function MUST return a value of either phantom.APP_SUCCESS or
        phantom.APP_ERROR. If this function returns phantom.APP_ERROR, then AppConnector::handle_action will not get
        called.
        """
        try:
            self._python_version = int(sys.version_info[0])
        except:
            return self.set_status(phantom.APP_ERROR, "Error occurred while getting the Phantom server's Python major version.")

        config = self.get_config()

        # Initialize configuration parameters
        self._base_url = config[consts.MDL_CONFIG_SERVER].strip('/')

        # override the validations, since the website allows anything and everything at this point
        self.set_validator("domain", self.validate_param)
        self.set_validator("url", self.validate_param)

        return phantom.APP_SUCCESS

    def _make_rest_call(self, endpoint, action_result, data=None, method="get", timeout=30):
        """ Function that makes the REST call to the device. It is a generic function that can be called from various
        action handlers.

        :param endpoint: REST endpoint that needs to appended to the service address
        :param action_result: object of ActionResult class
        :param data: request body
        :param method: method used for making request (Default method is 'post')
        :return: status success/failure(along with appropriate message), response obtained by making an API call
        """

        response_data = None

        if not data:
            data = {}

        # All API calls supports POST request
        try:
            request_func = getattr(requests, method)
        except AttributeError:
            self.debug_print(consts.MDL_ERR_API_UNSUPPORTED_METHOD)
            # set the action_result status to error, the handler function will most probably return as is
            return action_result.set_status(phantom.APP_ERROR, consts.MDL_ERR_API_UNSUPPORTED_METHOD), response_data
        except Exception as e:
            self.debug_print(consts.MDL_EXCEPTION_OCCURRED.format(error=e))
            # set the action_result status to error, the handler function will most probably return as is
            return action_result.set_status(phantom.APP_ERROR, e), response_data

        try:
            response = request_func('{}{}'.format(self._base_url, endpoint), params=data, timeout=timeout)
        except Exception as error:
            error_message = self._get_error_message_from_exception(error)
            self.debug_print(consts.MDL_REST_CALL_ERROR.format(error=error_message))
            # Set the action_result status to error, the handler function will most probably return as is
            return action_result.set_status(phantom.APP_ERROR, consts.MDL_ERR_SERVER_CONNECTION,
                                            error_message), response_data

        # store the r_text in debug data, it will get dumped in the logs if an error occurs
        if hasattr(action_result, 'add_debug_data'):
            if (response is not None):
                action_result.add_debug_data({'r_status_code': response.status_code})
                action_result.add_debug_data({'r_text': response.text})
                action_result.add_debug_data({'r_headers': response.headers})
            else:
                action_result.add_debug_data({'r_text': 'r is None'})

        if response.status_code in ERROR_RESP_DICT:
            self.debug_print(consts.MDL_ERR_FROM_SERVER.format(status=response.status_code,
                                                               detail=ERROR_RESP_DICT[response.status_code],
                                                               reason=response.content))

            # Set the action_result status to error, the handler function will most probably return as is
            return action_result.set_status(phantom.APP_ERROR, '{0}'.format(consts.MDL_ERR_FROM_SERVER),
                                            status=response.status_code,
                                            detail=ERROR_RESP_DICT[response.status_code],
                                            reason=response.content), response_data

        if response.status_code == consts.MDL_SUCCESS_RESPONSE:
            return phantom.APP_SUCCESS, {consts.MDL_REST_RESPONSE: response.content,
                                         consts.MDL_REST_RESPONSE_HEADERS: response.headers}

        # Set the action_result status to error, the handler function will most probably return as is
        return action_result.set_status(phantom.APP_ERROR, consts.MDL_ERR_FROM_SERVER,
                                        status=response.status_code,
                                        detail=consts.MDL_UNKNOWN_ERROR,
                                        reason=response.content), response.content

    def _extract_ioc(self, value):
        tmp = value.lower()
        if not (value.startswith("http://") or value.startswith("https://")):
            tmp = "http://" + value
        hostname = urlparse(tmp).hostname
        domain = hostname if phantom.is_domain(hostname) else None
        ip = hostname if phantom.is_ip(hostname) else None
        return domain, ip

    def _parse_response(self, response_content, action_result, summary_data):
        soup = BeautifulSoup(response_content, "html.parser")
        keys = []
        # get data paths
        for i, r in enumerate(soup.findAll("tr", {"class": "tabletitle"})):
            for j, c in enumerate(r.findAll("td")):
                try:
                    keys += [c.contents[0].get_text()]
                except AttributeError:  # AttributeError: 'NavigableString' object has no attribute 'get_text'
                    keys += [c.contents[0]]
                except IndexError:
                    pass
                except Exception:
                    pass
            break
        keys = [re.sub("[ ()]", "", k) for k in keys]

        # get ioc
        malicious = 0
        processed_everything = len(keys) > 0
        for i, r in enumerate(soup.findAll("tr", {"onmouseover": "this.style.backgroundColor='#b6bac6'"})):
            malicious += 1
            data = {}
            try:
                for j, c in enumerate(r.findAll("td")):
                    if j < len(keys):
                        value = re.sub('<[^>]*>', '', unicode(c) if self._python_version < 3 else str(c))
                        if value[-1] == "." and keys[j] == consts.MDL_JSON_DATAPATH_REVERSE_LOOKUP:
                            data[keys[j]] = value[:-1]
                        elif keys[j] == consts.MDL_JSON_DATAPATH_DOMAIN:
                            data[consts.MDL_JSON_DATAPATH_PATH] = value
                            domain, data[consts.MDL_JSON_DATAPATH_IP] = self._extract_ioc(value)
                            if domain != "-":
                                data[consts.MDL_JSON_DATAPATH_DOMAIN] = domain
                        elif keys[j] == consts.MDL_JSON_DATAPATH_IP:
                            if phantom.is_ip(value):
                                data[consts.MDL_JSON_DATAPATH_IP] = value
                            else:
                                data[consts.MDL_JSON_DATAPATH_PATH] = value
                                _, data[consts.MDL_JSON_DATAPATH_IP] = self._extract_ioc(value)
                        else:
                            data[keys[j]] = value
                    else:
                        for country in c.findAll("img", {"class": True, "title": True, "alt": True}):
                            data[consts.MDL_JSON_DATAPATH_COUNTRY] = country["title"]
                            data[consts.MDL_JSON_DATAPATH_COUNTRY_CODE] = country["alt"]
                            break
                action_result.add_data(data)
            except:
                processed_everything = False

        summary_data.update({"matching_records": malicious})
        summary_data.update({"malicious": True if malicious > 0 else False})

        if (not processed_everything):
            return action_result.set_status(phantom.APP_ERROR, "Some of the data could not be processed")

        return phantom.APP_SUCCESS

    def _ip_reputation(self, param):
        """ Function to query Malware Domain List to get IP details.

        :param param: dictionary of input parameter containing IP
        :return: status success/failure
        """

        action_result = self.add_action_result(ActionResult(dict(param)))
        summary_data = action_result.update_summary({})

        # getting parameters
        inactive = param.get(consts.MDL_JSON_INCLUDE_INACTIVE, False)
        ip = param[consts.MDL_JSON_IP]

        api_params = {consts.MDL_JSON_COLSEARCH: consts.MDL_JSON_PARAM_IP, consts.MDL_JSON_QUANTITY: consts.MDL_JSON_PARAM_ALL,
            consts.MDL_JSON_ASCORDESC: consts.MDL_JSON_PARAM_DESC}
        api_params[consts.MDL_JSON_SEARCH] = ip
        if inactive:
            api_params[consts.MDL_JSON_INACTIVE] = consts.MDL_JSON_PARAM_INACTIVE_ON

        # make REST call
        response_status, response_data = self._make_rest_call(consts.MDL_SEARCH_ENDPOINT, action_result,
                                                              data=api_params)

        if phantom.is_fail(response_status):
            return action_result.get_status()

        # parse results
        ret_val = self._parse_response(response_data[consts.MDL_REST_RESPONSE], action_result, summary_data)

        if (phantom.is_fail(ret_val)):
            return action_result.get_status()

        return action_result.set_status(phantom.APP_SUCCESS)

    def _domain_reputation(self, param):
        """ Function to query Malware Domain List to get domain details.

        :param param: domain to search
        :return: status success/failure
        """

        action_result = self.add_action_result(ActionResult(dict(param)))
        summary_data = action_result.update_summary({})

        # getting parameters
        inactive = param.get(consts.MDL_JSON_INCLUDE_INACTIVE, False)
        domain = param[consts.MDL_JSON_DOMAIN]

        # Convert URL to domain
        if phantom.is_url(domain):
            domain = phantom.get_host_from_url(domain)

        api_params = {consts.MDL_JSON_COLSEARCH: consts.MDL_JSON_PARAM_DOMAIN, consts.MDL_JSON_QUANTITY: consts.MDL_JSON_PARAM_ALL,
            consts.MDL_JSON_ASCORDESC: consts.MDL_JSON_PARAM_DESC}
        api_params[consts.MDL_JSON_SEARCH] = domain
        if inactive:
            api_params[consts.MDL_JSON_INACTIVE] = consts.MDL_JSON_PARAM_INACTIVE_ON

        # make REST call
        response_status, response_data = self._make_rest_call(consts.MDL_SEARCH_ENDPOINT, action_result,
                                                              data=api_params)

        if phantom.is_fail(response_status):
            return action_result.get_status()

        # parse results
        ret_val = self._parse_response(response_data[consts.MDL_REST_RESPONSE], action_result, summary_data)

        if (phantom.is_fail(ret_val)):
            return action_result.get_status()

        return action_result.set_status(phantom.APP_SUCCESS)

    def _test_connectivity(self, param):
        """ This function tests the connectivity to the Malware Domain List server.

        :param param: dictionary of input parameters
        :return: status (success/failure)
        """

        action_result = ActionResult()
        self.save_progress(consts.MDL_TEST_ENDPOINT_MSG)
        self.save_progress("Connecting to {}{}...".format(self._base_url, consts.MDL_SEARCH_ENDPOINT))

        # Querying endpoint to check connection to device
        status, response = self._make_rest_call(consts.MDL_SEARCH_ENDPOINT, action_result)

        if phantom.is_fail(status):
            self.save_progress(action_result.get_message())
            self.set_status(phantom.APP_ERROR, consts.MDL_TEST_CONN_FAIL)
            return action_result.get_status()

        self.set_status_save_progress(phantom.APP_SUCCESS, consts.MDL_TEST_CONN_SUCC)
        return action_result.get_status()

    def handle_action(self, param):
        """ This function gets current action identifier and calls member function of its own to handle the action.

        :param param: dictionary which contains information about the actions to be executed
        :return: status success/failure
        """

        # Dictionary mapping each action with its corresponding actions
        action_mapping = {
            'ip_reputation': self._ip_reputation,
            'domain_reputation': self._domain_reputation,
            'test_connectivity': self._test_connectivity
        }

        action = self.get_action_identifier()
        action_execution_status = phantom.APP_SUCCESS

        if action in list(action_mapping.keys()):
            action_function = action_mapping[action]
            action_execution_status = action_function(param)

        return action_execution_status


if __name__ == '__main__':

    import pudb

    pudb.set_trace()
    if len(sys.argv) < 2:
        print('No test json specified as input')
        exit(0)
    with open(sys.argv[1]) as f:
        in_json = f.read()
        in_json = json.loads(in_json)
        print(json.dumps(in_json, indent=4))
        connector = MalwareDomainListConnector()
        connector.print_progress_message = True
        return_value = connector._handle_action(json.dumps(in_json), None)
        print(json.dumps(json.loads(return_value), indent=4))
    exit(0)
